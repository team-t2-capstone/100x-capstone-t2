Nice — here’s a clear, practical step-by-step guide to authenticate users with Supabase, keep their session alive, and refresh tokens safely. I’ll show the common client + server pattern (browser client + Node/Express server) because that’s the pattern most apps use — but the same ideas apply to other frameworks.

---

# TL;DR

1. Sign the user in with `supabase.auth.signInWithPassword(...)` (or OAuth).
2. Capture the `session` (it contains `access_token` (JWT) and `refresh_token`).
3. Store tokens securely — **prefer** server-side httpOnly cookies when possible.
4. When the access token expires, call `supabase.auth.refreshSession({ refresh_token })` (server-side) to get a new `access_token` + `refresh_token` and update storage.
5. Let the client call a server `/auth/refresh` endpoint (or use supabase-js auto-refresh in browser) to keep the session alive. ([Supabase][1])

---

## Prerequisites

* `@supabase/supabase-js` installed on client and `@supabase/supabase-js` on server (same package can be used both places).
* Supabase project URL (`SUPABASE_URL`) and keys:

  * **Anon/public** key used in browser.
  * **Service role / server secret** stored only on server (for privileged server ops / configuration). ([Supabase][2])

---

## 1) Sign in (client)

Use the modern API (`signInWithPassword`) to authenticate and get a session object:

```js
// client.js (browser)
import { createClient } from '@supabase/supabase-js'
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)

async function signIn(email, password) {
  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password
  })
  if (error) throw error
  // data.session contains access_token and refresh_token
  return data.session
}
```

`data.session` has `access_token` (JWT) and a `refresh_token`. You can inspect them during development to understand expiry times. ([Supabase][1])

---

## 2) Decide where to store tokens (tradeoffs)

**Options**

* **Server-side HttpOnly cookies (recommended for web apps)** — best protection from XSS. Server can read refresh token and refresh session, and set short-lived access token cookie.
* **Browser storage (localStorage / memory)** — easy, but vulnerable to XSS. Supabase client SDK will by default store sessions in localStorage and auto-refresh for browser apps.
* **Cookies but not HttpOnly** — sometimes what Supabase docs use for SSR; Supabase docs note the browser side often needs access to the refresh token for browser flows (they discuss multiple approaches). Choose based on your app architecture. ([Supabase][3])

**Recommendation:** For typical server-rendered / server-API apps, on sign-in send the refresh token to your server and set secure, httpOnly cookies for `sb-access-token` and `sb-refresh-token`. Use CSRF protections on state-changing requests.

---

## 3) Example: send session to server and set httpOnly cookies

**Client** sends session to server after sign-in:

```js
// after sign in on client
const session = data.session
await fetch('/api/auth/session', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(session) // or just refresh_token
})
```

**Server (Express) endpoint** sets httpOnly cookies:

```js
// server.js (Node/Express)
import express from 'express'
import cookieParser from 'cookie-parser'
import { createClient } from '@supabase/supabase-js'

const app = express()
app.use(express.json())
app.use(cookieParser())

const supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_SERVICE_ROLE_KEY)

// Accept session and set cookies
app.post('/api/auth/session', (req, res) => {
  const { access_token, refresh_token, expires_at } = req.body
  // set httpOnly secure cookies (example)
  res.cookie('sb-access-token', access_token, {
    httpOnly: true,
    secure: true,
    sameSite: 'lax',
    maxAge: 1000 * 60 * 60 // set to access token lifetime
  })
  res.cookie('sb-refresh-token', refresh_token, {
    httpOnly: true,
    secure: true,
    sameSite: 'lax',
    maxAge: 1000 * 60 * 60 * 24 * 30 // refresh token lifetime (example)
  })
  res.send({ ok: true })
})
```

> Note: Supabase docs discuss various cookie approaches for SSR and server-side flows — choose the one that fits your stack. ([Supabase][4])

---

## 4) Refreshing tokens (server-side endpoint)

When an access token expires, server uses the stored refresh token to request a new session.

**Server refresh endpoint**:

```js
// server.js (continued)
app.post('/api/auth/refresh', async (req, res) => {
  const refresh_token = req.cookies['sb-refresh-token']
  if (!refresh_token) return res.status(401).send({ error: 'no refresh token' })

  // Use supabase.auth.refreshSession to exchange refresh token for a new session
  const { data, error } = await supabase.auth.refreshSession({ refresh_token })
  if (error) return res.status(401).send({ error: error.message })

  const { session } = data
  // update cookies with new tokens
  res.cookie('sb-access-token', session.access_token, { httpOnly:true, secure:true, sameSite:'lax', maxAge: 1000*60*60 })
  res.cookie('sb-refresh-token', session.refresh_token, { httpOnly:true, secure:true, sameSite:'lax', maxAge: 1000*60*60*24*30 })
  return res.send({ ok: true })
})
```

That `refreshSession({ refresh_token })` call is the canonical way to exchange a refresh token for a new access token + refresh token. ([Supabase][5])

**Important**: Supabase has protections for refresh token reuse and a “reuse interval” (small grace window) to support SSR and small races. Avoid concurrent refresh requests for the same refresh token — serialize refresh attempts in middleware if needed. ([Supabase][6])

---

## 5) Client behavior (how to trigger refresh)

* **Browser single-page app using supabase-js**: the client SDK auto-refreshes tokens for you and stores them (you typically don’t need a manual refresh endpoint). Use `supabase.auth.getSession()` to read current session. (Good for pure client apps.) ([Supabase][7], [GitHub][8])
* **SSR or cookie-based server flows**: the client should call your `/api/auth/refresh` endpoint when the server detects expired access token (or set middleware that ensures tokens are fresh on each protected request).

---

## 6) Middleware example (pseudo)

In your server middleware for protected routes:

1. Read `sb-access-token` cookie and verify (or call `supabase.auth.getUser()` with the access token).
2. If access token expired -> call `/api/auth/refresh` (or directly `supabase.auth.refreshSession` on server) to refresh and retry the request.
3. If refresh fails -> require re-login.

(You can use `supabase.auth.getUser()` or verify JWT manually if desired.)

---

## 7) Security & best practices (short list)

* **Never** expose `service_role` key to clients. Use it only server-side. ([Supabase][2])
* Prefer **httpOnly, Secure, SameSite** cookies for refresh tokens in web apps to mitigate XSS/CSRF. Add CSRF tokens when doing state-changing POSTs.
* Avoid storing refresh tokens in `localStorage` if you can. If you must use browser storage, protect against XSS. ([Supabase][9])
* Use Supabase’s session settings to control token lifetimes and refresh rotation in the dashboard.
* Handle race conditions: the refresh token may be single-use with a small reuse window — serialize refresh attempts or use the server to refresh once. ([GitHub][10], [Supabase][6])

---

## 8) Troubleshooting tips

* Check `supabase.auth.refreshSession` errors — common mistakes are sending `{ refresh: ... }` instead of `{ refresh_token: ... }`. The method expects a `refresh_token` field. ([GitHub][11])
* If your browser client already uses supabase-js and you also refresh on the server, be careful about the same refresh token being used in two places at the same time — that can cause “Invalid Refresh Token: Already Used” race errors. Serialize refreshes or centralize refresh logic on the server. ([GitHub][10])

---

## Quick checklist to implement right now

* [ ] Install `@supabase/supabase-js` on client and server.
* [ ] Implement client sign-in (`signInWithPassword` or OAuth). ([Supabase][1])
* [ ] Send refresh token to server and set httpOnly cookies (server endpoint).
* [ ] Implement `/api/auth/refresh` using `supabase.auth.refreshSession({ refresh_token })` and update cookies. ([Supabase][5])
* [ ] Add middleware to refresh tokens before protected operations.
* [ ] Harden cookies + CSRF and never leak service\_role key.

---

If you want, tell me:

* **Which stack** you’re using (React, Next.js, plain Express, Flask, etc.), and I’ll give a ready-to-drop-in code sample for that stack (including cookie flags, middleware, and an example refresh flow).

[1]: https://supabase.com/docs/reference/javascript/auth-signin?utm_source=chatgpt.com "JavaScript: Sign in a user | Supabase Docs"
[2]: https://supabase.com/docs/guides/api/api-keys?utm_source=chatgpt.com "Understanding API keys | Supabase Docs"
[3]: https://supabase.com/docs/guides/auth/server-side/advanced-guide?utm_source=chatgpt.com "Advanced guide | Supabase Docs"
[4]: https://supabase.com/docs/guides/auth/server-side?utm_source=chatgpt.com "Server-Side Rendering | Supabase Docs"
[5]: https://supabase.com/docs/reference/javascript/auth-refreshsession?utm_source=chatgpt.com "JavaScript: Retrieve a new session | Supabase Docs"
[6]: https://supabase.com/docs/guides/auth/sessions?utm_source=chatgpt.com "User sessions | Supabase Docs"
[7]: https://supabase.com/docs/reference/javascript/auth-startautorefresh?utm_source=chatgpt.com "JavaScript: Start auto-refresh session (non-browser) | Supabase Docs"
[8]: https://github.com/orgs/supabase/discussions/26718?utm_source=chatgpt.com "[supabase newbie] Don't understand why refresh token doesn't ..."
[9]: https://supabase.com/docs/guides/troubleshooting/how-do-i-make-the-cookies-httponly-vwweFx?utm_source=chatgpt.com "Troubleshooting | How do I make the cookies HttpOnly? - Supabase"
[10]: https://github.com/supabase/supabase/issues/18981?utm_source=chatgpt.com "Refresh token errors in @supabase/ssr · Issue #18981 - GitHub"
[11]: https://github.com/orgs/supabase/discussions/18694?utm_source=chatgpt.com "Generating a new access token server side #18694 - GitHub"
